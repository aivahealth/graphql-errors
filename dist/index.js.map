{"version":3,"sources":["../lib/index.js"],"names":["setDefaultHandler","maskErrors","Processed","IsUserError","UserError","args","name","message","Error","captureStackTrace","defaultHandler","err","errId","uuid","v4","console","error","stack","handlerFn","thing","fn","GraphQLSchema","maskSchema","GraphQLObjectType","maskType","maskField","field","resolveFn","resolve","out","call","_resolveFn","type","getFields","fields","fieldName","Object","hasOwnProperty","schema","types","getTypeMap","typeName"],"mappings":"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","file":"index.js","sourcesContent":["import uuid from 'uuid';\nimport {\n  GraphQLObjectType,\n  GraphQLSchema,\n} from 'graphql';\n\n\n// Mark field/type/schema\nexport const Processed = Symbol();\n\n\n// Used to identify UserErrors\nexport const IsUserError = Symbol();\n\n\n// UserErrors will be sent to the user\nexport class UserError extends Error {\n  constructor(...args) {\n    super(...args);\n    this.name = 'Error';\n    this.message = args[0];\n    this[IsUserError] = true;\n    Error.captureStackTrace(this, 'Error');\n  }\n}\n\n\n// Modifies errors before sending to the user\nexport let defaultHandler = function (err) {\n  if (err[IsUserError]) {\n    return err;\n  }\n  const errId = uuid.v4();\n  err.message = `${err.message}: ${errId}`;\n  console.error(err && err.stack || err);\n  err.message = `Internal Error: ${errId}`;\n  return err;\n};\n\n\n// Changes the default error handler function\nexport function setDefaultHandler(handlerFn) {\n  defaultHandler = handlerFn;\n}\n\n\n// Masks graphql schemas, types or individual fields\nexport function maskErrors(thing, fn = defaultHandler) {\n  if (thing instanceof GraphQLSchema) {\n    maskSchema(thing, fn);\n  } else if (thing instanceof GraphQLObjectType) {\n    maskType(thing, fn);\n  } else {\n    maskField(thing, fn);\n  }\n}\n\n\nfunction maskField(field, fn) {\n  const resolveFn = field.resolve;\n  if (field[Processed] || !resolveFn) {\n    return;\n  }\n\n  field[Processed] = true;\n  field.resolve = async function (...args) {\n    try {\n      const out = resolveFn.call(this, ...args);\n      return await Promise.resolve(out);\n    } catch (e) {\n      throw fn(e, args);\n    }\n  };\n\n  // save the original resolve function\n  field.resolve._resolveFn = resolveFn;\n}\n\n\nfunction maskType(type, fn) {\n  if (type[Processed] || !type.getFields) {\n    return;\n  }\n\n  const fields = type.getFields();\n  for (const fieldName in fields) {\n    if (!Object.hasOwnProperty.call(fields, fieldName)) {\n      continue;\n    }\n\n    maskField(fields[fieldName], fn);\n  }\n}\n\n\nfunction maskSchema(schema, fn) {\n  const types = schema.getTypeMap();\n  for (const typeName in types) {\n    if (!Object.hasOwnProperty.call(types, typeName)) {\n      continue;\n    }\n\n    maskType(types[typeName], fn);\n  }\n}\n"]}